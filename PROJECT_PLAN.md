# Wild Racing - 项目计划文档 (阶段一：单人模式)

**版本:** 1.0
**编写日期:** 2025-04-17


## 1. 项目概述

### 1.1. 项目目标

开发一款基于 Web 的 3D 赛车游戏，提供流畅的单人游戏体验。核心目标包括：

*   实现逼真的车辆物理模拟和驾驶感受。
*   提供多个可选车辆和赛道。
*   优化资源加载，减少等待时间，提升用户体验。
*   建立模块化的代码架构，便于维护和未来扩展（多人模式）。
*   在第一阶段，专注于实现完整的单人游戏核心循环，使用浏览器本地存储 (IndexedDB) 进行数据持久化。

### 1.2. 目标平台

*   现代桌面 Web 浏览器 (Chrome, Firefox, Edge, Safari)

### 1.3. 核心功能 (阶段一：单人模式)

*   **车辆选择:** 玩家可以从一组预定义的车辆中选择一辆进行比赛。
*   **赛道选择:** 玩家可以选择不同的赛道进行比赛。
*   **单人计时赛模式:**
    *   玩家在选定赛道上独自比赛，目标是创造最快圈速/总时间。
    *   包含起跑、检查点、圈数计算、冲线逻辑。
    *   记录并显示玩家在各赛道上的最佳成绩 (存储于 IndexedDB)。
*   **车辆物理:**
    *   基于 Cannon.js 实现车辆的加速、刹车、转向、重力、悬挂（简化）、轮胎摩擦。
    *   车辆与赛道、障碍物的碰撞检测及物理反馈。
*   **资源加载优化:**
    *   预加载核心资源（如菜单界面资源、默认车辆的前几个）。
    *   对车辆模型、赛道模型等大型资源采用懒加载策略。
    *   实现内存缓存和 IndexedDB 缓存机制，减少重复加载。
*   **用户设置:**
    *   允许玩家调整基本设置（如图形质量、音量、控制方式）。
    *   设置持久化存储于 IndexedDB。
*   **基础 UI:**
    *   主菜单、车辆选择、赛道选择界面。
    *   游戏内 HUD (速度表、圈数/检查点提示、计时器)。
    *   比赛结束/成绩显示界面。

## 2. 技术架构 (阶段一)

*   **渲染引擎:** Three.js (用于 3D 场景渲染、模型加载、动画)
*   **物理引擎:** Cannon.js (用于碰撞检测、刚体动力学、车辆物理模拟)
*   **客户端存储:** IndexedDB (使用 `src/utils/db/index.js` 封装)
    *   存储内容：用户设置、各赛道最佳成绩、已解锁内容（如果适用）、资源缓存（可选）。
*   **资源管理:** 自定义资源加载器 (`src/core/resources/`)
    *   负责模型 (.glb/.gltf)、纹理 (WebP/Basis)、音频、配置文件 (JSON) 的加载。
    *   实现预加载、懒加载、内存缓存、IndexedDB 缓存逻辑。
*   **编程语言:** JavaScript / TypeScript
*   **代码规范:** [待定，例如 Airbnb JavaScript Style Guide]
*   **版本控制:** Git


## 4. 实施计划与任务分解 (阶段一)

**里程碑 1: 基础框架与核心物理**

*   **任务 1.1:**
    *   **描述:** 初始化项目结构，配置构建工具 (如 Vite/Webpack)，设置 Three.js 基础场景和渲染循环。
    *   **产出:** 一个能显示基本 3D 场景的空项目。
*   **任务 1.2:**
    *   **描述:** 集成 Cannon.js，设置物理世界，添加地面，实现 `PhysicsWorld` 模块基本功能。
    *   **产出:** 包含物理引擎的场景，物体能响应重力。
*   **任务 1.3:** 
    *   **描述:** 创建 `InputManager` 模块，捕获键盘输入（油门、刹车、转向）。
    *   **产出:** 能够接收并处理用户基本输入的系统。
*   **任务 1.4:**
    *   **描述:** 创建基础车辆物理 (`VehiclePhysics` using `RaycastVehicle`)，将输入映射到车辆力/扭矩，使简易车辆模型（如方块）能在地面上移动。
    *   **产出:** 一个可通过键盘控制移动的方块。
*   **任务 1.5:** 
    *   **描述:** 实现 `CameraController`，提供基本的第三人称追随相机。
    *   **产出:** 相机能跟随移动的方块。

**里程碑 2: 资源加载与车辆集成**

*   **任务 2.1:** 
    *   **描述:** 开发 `AssetLoader` 和 `ModelCache` 模块 (`src/core/resources/`)。
    *   **产出:** 能够加载 `.glb` 模型的加载器。
*   **任务 2.2:** 
    *   **描述:** 实现模型预加载逻辑（加载前 7 个）。
    *   **产出:** 进入游戏前自动后台加载指定模型。
*   **任务 2.3:** 
    *   **描述:** 实现模型懒加载和内存缓存逻辑。
    *   **产出:** 只有在需要时才加载模型，加载过的模型直接从内存读取。
*   **任务 2.4:**
    *   **描述:** 实现 IndexedDB 缓存，存储已下载的模型 `ArrayBuffer`。
    *   **产出:** 关闭页面后重新打开，已缓存模型能更快加载（从 IndexedDB 读取）。
*   **任务 2.5:** 
    *   **描述:** 加载实际车辆模型，替换之前的方块。调整相机视角。
    *   **产出:** 游戏中使用真实车辆模型。
*   **任务 2.6:** 
    *   **描述:** 为车辆创建合适的 Cannon.js 碰撞体 (`ConvexPolyhedron` 或 `Compound`)，调整车辆物理参数（质量、重心、悬挂、轮胎摩擦）。
    *   **产出:** 车辆物理表现更真实，碰撞更准确。

**里程碑 3: 赛道与核心游戏逻辑**

*   **任务 3.1:** 
    *   **描述:** 开发 `TrackLoader`，加载赛道模型和配置文件（包含生成点、检查点、终点线信息）。
    *   **产出:** 能够在场景中加载赛道模型。
*   **任务 3.2:** 
    *   **描述:** 为赛道模型创建 Cannon.js 静态碰撞体 (`Trimesh` 或组合 `Box`)。定义赛道与车辆的 `ContactMaterial`。
    *   **产出:** 车辆能在赛道上行驶并与赛道边缘/障碍物发生碰撞。
*   **任务 3.3:** 
    *   **描述:** 实现 `RaceManager` 模块，管理单人计时赛流程（等待、倒计时、比赛中、结束）。
    *   **产出:** 游戏有明确的开始和结束状态。
*   **任务 3.4:** 
    *   **描述:** 在赛道上创建检查点和终点线的触发器 (`STATIC` Body with `isTrigger=true`)。在 `RaceManager` 中实现通过检测和圈数计算逻辑。
    *   **产出:** 能够正确记录玩家通过的检查点和完成的圈数。
*   **任务 3.5:**
    *   **描述:** 实现 `Timer` 模块，精确记录比赛时间。
    *   **产出:** 游戏内能显示实时计时。

**里程碑 4: UI 与持久化**

*   **任务 4.1:** 
    *   **描述:** 开发 IndexedDB 封装 (`src/utils/db/index.js`)，确保其健壮性。
    *   **产出:** 稳定可靠的 IndexedDB 读写接口。
*   **任务 4.2:** 
    *   **描述:** 实现比赛结束后成绩的记录（保存到 IndexedDB）和显示。
    *   **产出:** 玩家可以看到自己的最佳成绩并被持久化保存。
*   **任务 4.3:** 
    *   **描述:** 创建主菜单、车辆选择、赛道选择 UI (`src/components/`)。
    *   **产出:** 完整的游戏前流程界面。
*   **任务 4.4:** 
    *   **描述:** 创建游戏内 HUD (速度表、圈数、计时器)。
    *   **产出:** 玩家在比赛中能看到关键信息。
*   **任务 4.5:** 
    *   **描述:** 实现设置界面和 `UserSettings` 模块，允许调整音量、图形设置，并将选择保存到 IndexedDB。
    *   **产出:** 用户设置可以保存并在下次游戏时加载。

**里程碑 5: 打磨与测试**

*   **任务 5.1:** 
    *   **描述:** 添加基本音效（引擎、碰撞、UI反馈）。
    *   **产出:** 游戏有声音反馈。
*   **任务 5.2:** 
    *   **描述:** 添加视觉效果（简单的粒子效果、轮胎痕迹等）。
    *   **产出:** 视觉表现力提升。
*   **任务 5.3:** 
    *   **描述:** 进行全面的功能测试和兼容性测试。
    *   **产出:** Bug 列表和修复。
*   **任务 5.4:** 
    *   **描述:** 进行性能分析和优化（渲染性能、物理性能、加载时间）。
    *   **产出:** 更流畅的游戏体验。

## 5. 风险与挑战

*   **物理调优:** 车辆物理参数（悬挂、摩擦力等）的调整可能非常耗时，需要不断测试才能达到理想的驾驶手感。
*   **性能优化:** 在 Web 平台上运行复杂的 3D 场景和物理模拟可能遇到性能瓶颈，尤其是在中低端设备上。需要持续关注性能。
*   **资源大小:** 高质量的模型和纹理文件可能很大，影响加载时间和性能。需要严格的资源优化流程。
*   **浏览器兼容性:** 不同浏览器对 WebGL、Web Audio、IndexedDB 的支持可能存在细微差异。

## 6. 未来规划 (阶段二)

*   **后端服务:** 设计并实现基于 Node.js (Vercel Serverless) + 数据库 (Vercel Postgres/KV) 的后端。
*   **用户系统:** 实现用户注册、登录、认证。
*   **多人模式:**
    *   引入 WebSocket (Vercel Edge Functions 或第三方服务) 实现实时状态同步。
    *   设计比赛房间、匹配逻辑。
    *   处理网络延迟和状态一致性问题。
*   **在线排行榜:** 基于后端数据库实现全局排行榜。
*   **车辆定制化:** 更丰富的车辆外观和性能定制，并保存到后端。
*   **成就系统:** 添加游戏内成就。

---
**文档维护:** 请保持本文档的更新，反映项目进度、决策变更和新增任务。 


接下来完善赛道功能是提升游戏核心体验的关键。基于当前的项目结构，以下是一些可以推进的方向：
核心集成：让赛车在赛道上跑 (Race.vue)
加载赛道环境： 在 Race.vue 的 setup 或 onMounted 中，需要决定是加载预设赛道 (trackManager.loadTrack) 还是生成程序化赛道 (trackGenerator.generateTrack)。这可能需要一个新的“赛道选择”视图或通过路由参数传递。
添加赛道到场景/物理世界： 加载或生成赛道后，需要将其返回的 Three.js Object3D 添加到 scene.value，并将其对应的 Cannon-es Body 添加到 world.value。这是最基本的一步，让赛车有“地面”可以行驶。
物理材质： 确保赛道物理体 (CANNON.Body) 有合适的物理材质 (CANNON.Material)，以便设置与车轮的摩擦力等。
检查点系统 (CheckpointSystem.js & Race.vue)
初始化： 从加载/生成的赛道数据中获取检查点信息 (位置、大小、顺序)，并调用 checkpointSystem.initialize(checkpoints, { maxLaps: totalLaps.value })。
可视化： 调用 checkpointSystem.addCheckpointsToScene(scene.value) 将检查点的触发器（可能是透明的 THREE.Mesh）添加到场景中，以便调试时可以看到。
碰撞检测： 在 Race.vue 的物理更新逻辑中 (例如 onPhysicsUpdate 或 VehicleController 内部)，检测车辆 (carChassisBody) 是否与下一个检查点触发器发生碰撞。
触发通过： 如果发生碰撞且是正确的检查点顺序，调用 checkpointSystem.checkpointPassed(checkpointIndex)。
更新UI： 使用 checkpointSystem 的状态 (如 currentLap, lapTimes, raceFinished) 来更新比赛界面的圈数、计时等信息，替换掉当前的 placeholder 逻辑。
赛道编辑器 (TrackEditor.vue & TrackEditorView.vue)
物理集成： 当生成赛道 (generateTrack) 或放置物体 (onMouseClick in placement mode) 时，不仅要创建 Three.js 网格，还要创建对应的 CANNON.Body 并添加到 physicsWorld.value 中。
可视化编辑：
放置预览： 在 onMouseMove 中，当处于放置模式时，可以创建一个临时的预览物体 (例如半透明的锥桶) 并实时更新其位置到鼠标射线与地面的交点，给用户更直观的反馈。
编辑节点： 对于程序化赛道，可以考虑显示赛道的控制点，并允许用户拖动这些点来调整赛道形状。
保存/加载增强：
使用 IndexedDB: 将 saveTrack 函数修改为使用 trackService.js (需要先实现 trackService) 将赛道数据（包括节点、物体、生成参数等）保存到 IndexedDB，而不是 localStorage。
加载自定义赛道： 添加加载已保存自定义赛道的功能。
赛道内容 (TrackManager.js, TrackGenerator.js, TrackObjects.js)
更多预设： 创建更多不同风格的 .glb 赛道模型，并在 TrackManager 中注册它们。确保这些模型包含检查点信息（可以通过空的 Object3D 作为标记）或者有明确的路径可供提取。
生成选项： 增加 TrackGenerator 的选项，例如不同类型的弯道（发夹弯、S弯）、坡度变化、特殊路面（如沙地、冰面，需要不同的物理材质）。
更多物体： 在 TrackObjects.js 中添加更多类型的障碍物或道具模型（如跳板、水坑、减速带），并赋予它们相应的物理效果（如果需要）。
先让车能在“地面”跑: 聚焦于在 Race.vue 中加载一个简单的预设赛道（或生成一个基础环形赛道），确保其物理体被正确添加到 world，并且车辆能够在其上行驶而不会掉下去。
再集成检查点: 实现检查点的碰撞检测和 checkpointPassed 的调用，让圈数能够正确计算。