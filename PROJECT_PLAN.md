# Wild Racing - 项目计划文档 (阶段一：单人模式)

**版本:** 1.0
**编写日期:** 2025-04-17


## 1. 项目概述

### 1.1. 项目目标

开发一款基于 Web 的 3D 赛车游戏，提供流畅的单人游戏体验。核心目标包括：

*   实现逼真的车辆物理模拟和驾驶感受。
*   提供多个可选车辆和赛道。
*   优化资源加载，减少等待时间，提升用户体验。
*   建立模块化的代码架构，便于维护和未来扩展（多人模式）。
*   在第一阶段，专注于实现完整的单人游戏核心循环，使用浏览器本地存储 (IndexedDB) 进行数据持久化。

### 1.2. 目标平台

*   现代桌面 Web 浏览器 (Chrome, Firefox, Edge, Safari)

### 1.3. 核心功能 (阶段一：单人模式)

*   **车辆选择:** 玩家可以从一组预定义的车辆中选择一辆进行比赛。
*   **赛道选择:** 玩家可以选择不同的赛道进行比赛。
*   **单人计时赛模式:**
    *   玩家在选定赛道上独自比赛，目标是创造最快圈速/总时间。
    *   包含起跑、检查点、圈数计算、冲线逻辑。
    *   记录并显示玩家在各赛道上的最佳成绩 (存储于 IndexedDB)。
*   **车辆物理:**
    *   基于 Cannon.js 实现车辆的加速、刹车、转向、重力、悬挂（简化）、轮胎摩擦。
    *   车辆与赛道、障碍物的碰撞检测及物理反馈。
*   **资源加载优化:**
    *   预加载核心资源（如菜单界面资源、默认车辆的前几个）。
    *   对车辆模型、赛道模型等大型资源采用懒加载策略。
    *   实现内存缓存和 IndexedDB 缓存机制，减少重复加载。
*   **用户设置:**
    *   允许玩家调整基本设置（如图形质量、音量、控制方式）。
    *   设置持久化存储于 IndexedDB。
*   **基础 UI:**
    *   主菜单、车辆选择、赛道选择界面。
    *   游戏内 HUD (速度表、圈数/检查点提示、计时器)。
    *   比赛结束/成绩显示界面。

## 2. 技术架构 (阶段一)

*   **渲染引擎:** Three.js (用于 3D 场景渲染、模型加载、动画)
*   **物理引擎:** Cannon.js (用于碰撞检测、刚体动力学、车辆物理模拟)
*   **客户端存储:** IndexedDB (使用 `src/utils/db/index.js` 封装)
    *   存储内容：用户设置、各赛道最佳成绩、已解锁内容（如果适用）、资源缓存（可选）。
*   **资源管理:** 自定义资源加载器 (`src/core/resources/`)
    *   负责模型 (.glb/.gltf)、纹理 (WebP/Basis)、音频、配置文件 (JSON) 的加载。
    *   实现预加载、懒加载、内存缓存、IndexedDB 缓存逻辑。
*   **编程语言:** JavaScript / TypeScript
*   **代码规范:** [待定，例如 Airbnb JavaScript Style Guide]
*   **版本控制:** Git

## 3. 代码模块设计

按照高内聚、低耦合原则，将代码组织为以下模块：

```
wild-racing-vercel/
├── public/             # 静态资源 (模型, 纹理, 音频 - 由资源模块管理加载)
├── src/
│   ├── components/     # UI 组件 (React/Vue/Svelte/Web Components)
│   │   ├── common/     # 通用 UI 元素 (按钮, 加载指示器)
│   │   ├── game/       # 游戏特定 UI (HUD, 菜单, 成绩板)
│   │   └── layout/     # 页面布局结构
│   ├── core/           # 核心引擎模块 (与具体游戏逻辑解耦)
│   │   ├── rendering/    # Three.js 相关: 场景设置, 渲染循环, 相机控制, 灯光
│   │   │   ├── SceneManager.js
│   │   │   ├── CameraController.js
│   │   │   └── Renderer.js
│   │   ├── physics/      # Cannon.js 相关: 世界设置, 物理同步, 碰撞材质, 触发器
│   │   │   ├── PhysicsWorld.js
│   │   │   └── materials.js
│   │   ├── resources/    # 资源加载与管理
│   │   │   ├── AssetLoader.js  # 核心加载逻辑
│   │   │   ├── ModelCache.js   # 缓存实现 (内存 + IndexedDB)
│   │   │   └── TrackLoader.js  # 赛道模型和配置加载
│   │   └── input/        # 输入处理 (键盘, 手柄适配)
│   │       └── InputManager.js
│   ├── game/           # 游戏逻辑模块
│   │   ├── user/         # 用户本地状态管理
│   │   │   └── UserSettings.js # 读写 IndexedDB 中的设置
│   │   ├── vehicle/      # 车辆逻辑
│   │   │   ├── Vehicle.js        # 车辆基类/接口
│   │   │   ├── VehicleController.js # 连接输入、物理和车辆状态
│   │   │   └── VehiclePhysics.js  # Cannon.js 车辆物理实现 (RaycastVehicle)
│   │   ├── race/         # 比赛逻辑 (单人模式)
│   │   │   ├── RaceManager.js    # 比赛状态机, 流程控制
│   │   │   ├── Track.js          # 赛道数据表示 (含检查点, 终点线)
│   │   │   └── Timer.js          # 计时器逻辑
│   │   └── state/        # 全局游戏状态管理 (可选, 如使用 Zustand/Redux/Context)
│   ├── utils/          # 通用工具函数和类
│   │   ├── db/           # IndexedDB 封装
│   │   │   └── index.js
│   │   ├── logger.js     # 日志工具
│   │   └── helpers.js    # 其他辅助函数
│   ├── styles/         # CSS 样式
│   ├── App.js / main.js # 应用入口
│   └── index.css       # 全局样式入口
├── .gitignore
├── package.json
└── README.md
```

## 4. 实施计划与任务分解 (阶段一)

**里程碑 1: 基础框架与核心物理**

*   **任务 1.1:**
    *   **描述:** 初始化项目结构，配置构建工具 (如 Vite/Webpack)，设置 Three.js 基础场景和渲染循环。
    *   **产出:** 一个能显示基本 3D 场景的空项目。
*   **任务 1.2:**
    *   **描述:** 集成 Cannon.js，设置物理世界，添加地面，实现 `PhysicsWorld` 模块基本功能。
    *   **产出:** 包含物理引擎的场景，物体能响应重力。
*   **任务 1.3:** 
    *   **描述:** 创建 `InputManager` 模块，捕获键盘输入（油门、刹车、转向）。
    *   **产出:** 能够接收并处理用户基本输入的系统。
*   **任务 1.4:**
    *   **描述:** 创建基础车辆物理 (`VehiclePhysics` using `RaycastVehicle`)，将输入映射到车辆力/扭矩，使简易车辆模型（如方块）能在地面上移动。
    *   **产出:** 一个可通过键盘控制移动的方块。
*   **任务 1.5:** 
    *   **描述:** 实现 `CameraController`，提供基本的第三人称追随相机。
    *   **产出:** 相机能跟随移动的方块。

**里程碑 2: 资源加载与车辆集成**

*   **任务 2.1:** 
    *   **描述:** 开发 `AssetLoader` 和 `ModelCache` 模块 (`src/core/resources/`)。
    *   **产出:** 能够加载 `.glb` 模型的加载器。
*   **任务 2.2:** 
    *   **描述:** 实现模型预加载逻辑（加载前 7 个）。
    *   **产出:** 进入游戏前自动后台加载指定模型。
*   **任务 2.3:** 
    *   **描述:** 实现模型懒加载和内存缓存逻辑。
    *   **产出:** 只有在需要时才加载模型，加载过的模型直接从内存读取。
*   **任务 2.4:**
    *   **描述:** 实现 IndexedDB 缓存，存储已下载的模型 `ArrayBuffer`。
    *   **产出:** 关闭页面后重新打开，已缓存模型能更快加载（从 IndexedDB 读取）。
*   **任务 2.5:** 
    *   **描述:** 加载实际车辆模型，替换之前的方块。调整相机视角。
    *   **产出:** 游戏中使用真实车辆模型。
*   **任务 2.6:** 
    *   **描述:** 为车辆创建合适的 Cannon.js 碰撞体 (`ConvexPolyhedron` 或 `Compound`)，调整车辆物理参数（质量、重心、悬挂、轮胎摩擦）。
    *   **产出:** 车辆物理表现更真实，碰撞更准确。

**里程碑 3: 赛道与核心游戏逻辑**

*   **任务 3.1:** 
    *   **描述:** 开发 `TrackLoader`，加载赛道模型和配置文件（包含生成点、检查点、终点线信息）。
    *   **产出:** 能够在场景中加载赛道模型。
*   **任务 3.2:** 
    *   **描述:** 为赛道模型创建 Cannon.js 静态碰撞体 (`Trimesh` 或组合 `Box`)。定义赛道与车辆的 `ContactMaterial`。
    *   **产出:** 车辆能在赛道上行驶并与赛道边缘/障碍物发生碰撞。
*   **任务 3.3:** 
    *   **描述:** 实现 `RaceManager` 模块，管理单人计时赛流程（等待、倒计时、比赛中、结束）。
    *   **产出:** 游戏有明确的开始和结束状态。
*   **任务 3.4:** 
    *   **描述:** 在赛道上创建检查点和终点线的触发器 (`STATIC` Body with `isTrigger=true`)。在 `RaceManager` 中实现通过检测和圈数计算逻辑。
    *   **产出:** 能够正确记录玩家通过的检查点和完成的圈数。
*   **任务 3.5:**
    *   **描述:** 实现 `Timer` 模块，精确记录比赛时间。
    *   **产出:** 游戏内能显示实时计时。

**里程碑 4: UI 与持久化**

*   **任务 4.1:** 
    *   **描述:** 开发 IndexedDB 封装 (`src/utils/db/index.js`)，确保其健壮性。
    *   **产出:** 稳定可靠的 IndexedDB 读写接口。
*   **任务 4.2:** 
    *   **描述:** 实现比赛结束后成绩的记录（保存到 IndexedDB）和显示。
    *   **产出:** 玩家可以看到自己的最佳成绩并被持久化保存。
*   **任务 4.3:** 
    *   **描述:** 创建主菜单、车辆选择、赛道选择 UI (`src/components/`)。
    *   **产出:** 完整的游戏前流程界面。
*   **任务 4.4:** 
    *   **描述:** 创建游戏内 HUD (速度表、圈数、计时器)。
    *   **产出:** 玩家在比赛中能看到关键信息。
*   **任务 4.5:** 
    *   **描述:** 实现设置界面和 `UserSettings` 模块，允许调整音量、图形设置，并将选择保存到 IndexedDB。
    *   **产出:** 用户设置可以保存并在下次游戏时加载。

**里程碑 5: 打磨与测试**

*   **任务 5.1:** 
    *   **描述:** 添加基本音效（引擎、碰撞、UI反馈）。
    *   **产出:** 游戏有声音反馈。
*   **任务 5.2:** 
    *   **描述:** 添加视觉效果（简单的粒子效果、轮胎痕迹等）。
    *   **产出:** 视觉表现力提升。
*   **任务 5.3:** 
    *   **描述:** 进行全面的功能测试和兼容性测试。
    *   **产出:** Bug 列表和修复。
*   **任务 5.4:** 
    *   **描述:** 进行性能分析和优化（渲染性能、物理性能、加载时间）。
    *   **产出:** 更流畅的游戏体验。

## 5. 风险与挑战

*   **物理调优:** 车辆物理参数（悬挂、摩擦力等）的调整可能非常耗时，需要不断测试才能达到理想的驾驶手感。
*   **性能优化:** 在 Web 平台上运行复杂的 3D 场景和物理模拟可能遇到性能瓶颈，尤其是在中低端设备上。需要持续关注性能。
*   **资源大小:** 高质量的模型和纹理文件可能很大，影响加载时间和性能。需要严格的资源优化流程。
*   **浏览器兼容性:** 不同浏览器对 WebGL、Web Audio、IndexedDB 的支持可能存在细微差异。

## 6. 未来规划 (阶段二)

*   **后端服务:** 设计并实现基于 Node.js (Vercel Serverless) + 数据库 (Vercel Postgres/KV) 的后端。
*   **用户系统:** 实现用户注册、登录、认证。
*   **多人模式:**
    *   引入 WebSocket (Vercel Edge Functions 或第三方服务) 实现实时状态同步。
    *   设计比赛房间、匹配逻辑。
    *   处理网络延迟和状态一致性问题。
*   **在线排行榜:** 基于后端数据库实现全局排行榜。
*   **车辆定制化:** 更丰富的车辆外观和性能定制，并保存到后端。
*   **成就系统:** 添加游戏内成就。

---
**文档维护:** 请保持本文档的更新，反映项目进度、决策变更和新增任务。 